#!/bin/env python
"""This script requires the following environment variables:

  - IAM_TOKEN
  - IAM_REFRESH_TOKEN
  - IAM_CLIENT_ID
  - IAM_CLIENT_SECRET
  - MARATHON_USER
  - MARATHON_PASSWD

"""
from __future__ import print_function

import ast
import json
import logging
import os
import subprocess
import sys
import time
from StringIO import StringIO

import requests
from urllib3._collections import HTTPHeaderDict

import pycurl
from kazoo.client import KazooClient


class ProxyManager(object):

    """Manager of tokens."""

    def __init__(self, env):
        # Get all environment variables
        self.iam_token = env.get('IAM_TOKEN')
        self.client_id = env.get('IAM_CLIENT_ID')
        self.client_secret = env.get('IAM_CLIENT_SECRET')
        self.marathon = {
            'user': env.get('MARATHON_USER'),
            'passwd': env.get('MARATHON_PASSWD'),
            'app_name': env.get('MARATHON_APP_ID'),
            'api_url': "https://marathon.service.consul:8443/v2/apps{}"
        }
        self.zookeeper_host_list = None
        self.zk_client = None

        ##
        # kazoo client needs a string with the list of zookeeper hosts
        # divided by a comma. This little piece of code converts the
        # list given as environment variable to a proper kazoo host string
        #Â and starts the connection only if ZOOKEEPER_HOST_LIST is not None.
        # In this phase we also prepare the zookeeper nodes to store variables.
        #
        # SOURCE: https://kazoo.readthedocs.io/en/latest/api/client.html#kazoo.client.KazooClient
        #
        # EXAMPLE:
        #   host1:port1,host2:port2,host3:port3
        #
        # NOTE:
        #   In zookeeper cms cluser are present these children from root ("/") node:
        #      ["marathon", "mesos", "zookeeper"]
        #   So path like "/marathon", "/mesos", "/zookeeper" are already available
        #
        if env.get('ZOOKEEPER_HOST_LIST') is not None:
            host_list = ast.literal_eval(env.get('ZOOKEEPER_HOST_LIST'))
            self.zookeeper_host_list = ",".join(
                [host+":2181" for host in host_list]
            )
            self.zk_client = KazooClient(hosts=self.zookeeper_host_list)
            self.zk_client.start()
            self.zk_client.ensure_path("/marathon/refresh_token")

        self.cache_dir = '/tmp/'
        self.token_expiration = 600000
        self.age = 20
        self.audience = 'https://watts.data.kit.edu'
        self.tts = 'https://watts.data.kit.edu'
        self.iam_endpoint = 'https://iam-test.indigo-datacloud.eu/'
        self.token_endpoint = self.iam_endpoint + 'token'
        self.introspect_endpoint = self.iam_endpoint + 'introspect'
        self.credential_endpoint = 'https://watts.data.kit.edu/api/v2/iam/credential'
        self.tts_output_data = '%s/output.json' % self.cache_dir
        self.lock_file = "%s/lock" % self.cache_dir
        self.user_cert = "%s/usercert.crt" % self.cache_dir
        self.user_key = "%s/userkey.key" % self.cache_dir
        self.user_passwd = "%s/userpasswd.txt" % self.cache_dir
        self.user_proxy = "%s/userproxy.pem" % self.cache_dir
        self.exchanged_token = ""
    
    def __del__(self):
        """Ensure to close all connection like zookeeper."""
        self.zk_client.stop()
    
    def zk_set_refresh_token(self, value):
        """Set the refresh token variable into the zookeeper environment.
        
        Params:
            value (string): the value of the refresh token
        
        Returns:
            kazoo.protocol.states.ZnodeStat

        """
        return self.zk_client.set("/marathon/refresh_token", value)
    
    def zk_get_refresh_token(self):
        """Returns the refresh token string.
        
        Notes:
            The method get of zk_client returns a byte string that have
            to be converted into a string with the method decode.
        """
        value, z_node_stat = self.zk_client.get("/marathon/refresh_token")
        return value.decode("utf-8")
        

    def call_marathon_api(self, method, data):
        """Interface to marathon REST API.

        This method can call only /v2/apps/{app_id} where
        app_id is passed by Marathon framework as environment
        variable.

        Params:
            method (string): an accepted method for the marathon API
                             like get, put, delete, patch, head
            data (dict): data to be serialized in JSON

        Example of use:

            call_marathon_api('patch', {
                'env': {
                    'new_variable': 123
                }
            })

            This function will call the following URL, because this script run
            in certcache marathon app:
                "https://marathon.service.consul:8443/v2/apps/certcache"

            with method patch and the passing data.
            In data will be inserted automatically the app id
            and will be converted to JSON string.
        """
        try:
            logging.info("METHOD: call_marathon_api")
            with requests.Session() as session:
                session.auth(self.marathon['user'], self.marathon['passwd'])
                logging.info("Using user: '%s' and passwd: '%s'",
                             self.marathon['user'], self.marathon['passwd'])

                selected_method = getattr(session, method)
                logging.info("Selecting method: %s", method)

                full_api_url = self.marathon['api_url'].format(
                    self.marathon['app_name']
                )
                logging.info("Using URL: %s", full_api_url)

                data['id'] = "/{}".format(self.marathon['app_name'])
                json_data = json.dumps(data)
                logging.info("JSON data: %s", json_data)

                res = selected_method(
                    full_api_url,
                    data=json_data,
                    verify=False  # Required to not verify the SSL certificate
                )
                logging.info("Marathon response: %s", res)

        except requests.exceptions.RequestException as exc:
            logging.error("Requests exception in call_marathon_api: '%s'", exc)

    def check_tts_data(self):
        """Checks and refresh tts data.

        Workflow:
            - Check cached TTS data
                - if exists and it's up to date -> ok
                - if it's not up to date -> refresh
                - else -> exchange token
        """
        if os.path.exists(self.tts_output_data):
            ctime = os.stat(self.tts_output_data).st_ctime
            since = time.time() - ctime
            if since > self.token_expiration:
                logging.debug("Token about to expire. Need refreshing")
                tts_data = self.get_tts_data(True)
            else:
                return True
        else:
            self.exchanged_token = self.get_exchange_token()
            if isinstance(self.exchanged_token, int):
                logging.error("Get_exchange_token error: %s",
                              self.exchanged_token)
                return False
            else:
                tts_data = self.get_tts_data(self.exchanged_token)

        return tts_data

    def get_certificate(self, url):
        """Retrieve the certificate.
        
        Returns:
            The given tts token

        Raises:
            - redirect errors
            - curl errors
        
        TO DO:
            - Manage controls (gestisci controlli)
        """
        bearer = 'Authorization: Bearer ' + \
            str(self.exchanged_token).split('\n', 1)[0]
        data = json.dumps({"service_id": "x509"})

        headers = StringIO()
        buffers = StringIO()

        curl = pycurl.Curl()
        curl.setopt(pycurl.URL, url)
        curl.setopt(pycurl.HTTPHEADER, [
                    bearer, 'Content-Type: application/json'])
        curl.setopt(pycurl.POST, 1)
        curl.setopt(pycurl.POSTFIELDS, data)
        curl.setopt(curl.WRITEFUNCTION, buffers.write)
        curl.setopt(curl.HEADERFUNCTION, headers.write)
        curl.setopt(curl.VERBOSE, True)

        try:
            curl.perform()
            status = curl.getinfo(curl.RESPONSE_CODE)
            curl.close()
            body = buffers.getvalue()

            if str(status) != "303":
                logging.error(
                    "On 'get redirected with curl': %s, http error: %s", body, str(status))
                return False
        except pycurl.error as error:
            errno, errstr = error
            logging.info('A pycurl error n. %s occurred: %s', errno, errstr)
            return False

        redirect = self.tts
        for item in headers.getvalue().split("\n"):
            if "location" in item:
                redirect = redirect + item.strip().replace("location: ", "")

                headers = {'Authorization': 'Bearer ' +
                           self.exchanged_token.strip()}
                response = requests.get(redirect, headers=headers)

                try:
                    response.raise_for_status()
                except requests.exceptions.HTTPError as err:
                    # Whoops it wasn't a 200
                    logging.error("Error in get_certificate(): %s", str(err))
                    return False

                with open('/tmp/output.json', 'w') as outf:
                    outf.write(response.content)
            else:
                logging.error("No location in redirect response")

        return True

    def get_exchange_token(self):
        """Retrieve the access token.

        Exchange the access token with the given client id and secret.
        The refresh token in cached and the exchange token is kept in memory.

        TO DO:
            - Add controls (aggiungi controlli)
        """
        data = HTTPHeaderDict()
        data.add('grant_type', 'urn:ietf:params:oauth:grant-type:token-exchange')
        data.add('audience', self.audience)
        data.add('subject_token', self.iam_token)
        data.add('scope', 'openid profile offline_access')

        logging.info("Call get_exchanged_token with data: %s", data)

        response = requests.post(self.token_endpoint, data=data, auth=(
            self.client_id, self.client_secret), verify=True)
        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as err:
            # Whoops it wasn't a 200
            logging.error("Error in get_exchange_token: %s", err)
            return response.status_code

        result = json.loads(response.content)

        with open('/tmp/refresh_token', 'w') as outf:
            outf.write(result["refresh_token"])

        ##
        # TO DO:
        # - Integrate this call
        # self.call_marathon_api('patch', {
        #     'env': {
        #         'IAM_REFRESH_TOKEN': result["refresh_token"]
        #     }
        # })

        return result["access_token"]

    def introspection(self, iam_client_id, iam_client_secret, exchanged_token):
        """Get info through introspection with the given client id, secret and token.

        TO DO:
            - Add controls (aggiungi controlli)
        """

        iam_client_id = self.client_id
        iam_client_secret = self.client_secret

        data = HTTPHeaderDict()
        data.add('token', exchanged_token)

        response = requests.post(self.introspect_endpoint, data=data, auth=(
            iam_client_id, iam_client_secret), verify=False)

        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as err:
            # Whoops it wasn't a 200
            logging.error("Error in introspection: %s", err)
            logging.error("HTTP error. Response status: %s",
                          response.status_code)
            return response.status_code

        with open('/tmp/introspection', 'w') as outf:
            outf.write(response.content)

    def refresh_token(self, refresh_token):
        """Request with refresh token.
        
        TO DO:
            - Manage result out of the function (gestisci result fuori dalla funzione)
        """
, 
        data = HTTPHeaderDict()
        data.add('client_id', self.client_id)
        data.add('client_secret', self.client_secret)
        data.add('grant_type', 'refresh_token')
        data.add('refresh_token', refresh_token)

        logging.info("refresh_token. data: %s", data)

        response = requests.post(self.token_endpoint, data=data, verify=True)

        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as err:
            # Whoops it wasn't a 200
            logging.error("Error in refresh_token: %s", err)
            logging.error("HTTP error. Response status: %s",
                          response.status_code)
            return response.status_code

        result = json.loads(response.content)
        return result["access_token"]

    def get_tts_data(self, exchange=False):
        """Get TTS data using a lock procedure.

        Phases:
            - get lock
            - retrieve_tts_data
            - release lock

        Params:
            exchange (Bool): indicate if we have to do the exchange
        """
        if os.path.exists(self.lock_file):
            ctime = os.stat(self.lock_file).st_ctime
            age = time.time() - ctime
            if age < self.age:
                logging.error("Update already in progres. Sleeping ...")
                time.sleep(self.age - age)
            else:
                logging.error("Stale lock file, removing ...")
                os.remove(self.lock_file)
        open(self.lock_file, 'w+').close()

        if exchange:
            with file('/tmp/refresh_token') as refresh_t_file:
                refresh_token = refresh_t_file.read()
                self.exchanged_token = self.refresh_token(refresh_token.strip())
                if isinstance(self.exchanged_token, int):
                    logging.error("Error in refresh_token")

        if self.get_certificate(self.credential_endpoint):
            # load json and prepare objects
            with open('/tmp/output.json') as tts_data_file:
                tts_data = json.load(tts_data_file)

            with open(self.user_cert, 'w+') as cur_file:
                cur_file.write(
                    str(tts_data['credential']['entries'][0]['value']))

            with open(self.user_key, 'w+') as cur_file:
                cur_file.write(
                    str(tts_data['credential']['entries'][1]['value']))

            with open(self.user_passwd, 'w+') as cur_file:
                cur_file.write(
                    str(tts_data['credential']['entries'][2]['value']))

            try:
                os.chmod(self.user_key, 0o600)
            except OSError as err:
                logging.error(
                    "Permission denied to chmod passwd file: %s", err)
                return False

            os.remove(self.lock_file)

            return True

        return False

    def generate_proxy(self):
        """Generates proxy with grid-proxy-init only if there are not errors."""

        if self.check_tts_data():
            logging.info("Generating proxy for %s", self.exchanged_token)

            command = "grid-proxy-init -valid 160:00 -key {} -cert {} -out {} -pwstdin ".format(
                self.user_key, self.user_cert, self.user_proxy
            )
            with open(self.user_passwd) as my_stdin:
                my_passwd = my_stdin.read()
            proxy_init = subprocess.Popen(
                command,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                shell=True
            )
            proxy_out, proxy_err = proxy_init.communicate(input=my_passwd)
            if proxy_init.returncode > 0:
                logging.error("grid-proxy-init failed for token %s",
                              self.exchanged_token)
                logging.error("grid-proxy-init failed stdout %s", proxy_out)
                logging.error("grid-proxy-init failed stderr %s", proxy_err)
            else:
                return self.user_proxy
        else:
            logging.info("Error occured in check_tts_data!")


if __name__ == '__main__':

    logging.basicConfig(filename='/var/log/ttscache/certcache.log',
                        format='%(asctime)s: [%(levelname)s] %(message)s', level=logging.DEBUG)

    logging.info("CALLING GET PROXY")

    # imports tokens, id and secret
    ENV = {
        'IAM_TOKEN': os.environ.get("IAM_TOKEN", None),
        'REFRESH_TOKEN': os.environ.get("IAM_REFRESH_TOKEN", None),
        'CLIENT_ID': os.environ.get("IAM_CLIENT_ID", None),
        'CLIENT_SECRET': os.environ.get("IAM_CLIENT_SECRET", None),
        'MARATHON_USER': os.environ.get("MARATHON_USER", None),
        'MARATHON_PASSWD': os.environ.get("MARATHON_PASSWD", None),
        'ZOOKEEPER_HOST_LIST': os.environ.get("ZOOKEEPER_HOST_LIST", None),
    }

    logging.info("IAM_TOKEN = %s", ENV.get('IAM_TOKEN'))
    logging.info("IAM_REFRESH_TOKEN = %s", ENV.get('REFRESH_TOKEN'))
    logging.info("IAM_CLIENT_= %s", ENV.get('CLIENT_ID'))
    logging.info("IAM_CLIENT_SECRET = %s", ENV.get('CLIENT_SECRET'))
    logging.info("MARATHON_USER = %s", ENV.get('MARATHON_USER'))
    logging.info("MARATHON_PASSWD = %s", ENV.get('MARATHON_PASSWD'))
    logging.info("ZOOKEEPER_HOST_LIST = %s", ENV.get('ZOOKEEPER_HOST_LIST'))

    PROXY_MANAGER = ProxyManager(ENV)

    print("Content-type: application/octet-stream\n\n")
    print("Content-Disposition: attachment; filename=.pem")
    print()
    PROXY_FILE = PROXY_MANAGER.generate_proxy()

    if PROXY_FILE is not None:
        with open(PROXY_FILE, 'rb') as proxy_file:
            print(proxy_file.read())
    else:
        logging.error("Cannot find Proxy file: '%s'", PROXY_FILE)
        print("Content-type: text/html")
        print()
        print("<p>grid-proxy-info failed</p>")
    sys.exit()
