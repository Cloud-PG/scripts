#!/bin/env python
"""This script requires the following environment variables:

  - IAM_TOKEN
  - IAM_REFRESH_TOKEN
  - IAM_CLIENT_ID
  - IAM_CLIENT_SECRET
  - MARATHON_USER
  - MARATHON_PASSWD

"""
from __future__ import print_function

import json
import logging
import os
import subprocess
import sys
import time
from StringIO import StringIO

import requests
from urllib3._collections import HTTPHeaderDict

import pycurl


class ProxyManager(object):

    """Manager of tokens."""

    def __init__(self, env):
        # Get all environment variables
        self.iam_token = env.get('IAM_TOKEN')
        self.client_id = env.get('IAM_CLIENT_ID')
        self.client_secret = env.get('IAM_CLIENT_SECRET')
        self.marathon = {
            'user': env.get('MARATHON_USER'),
            'passwd': env.get('MARATHON_PASSWD'),
            'app_name': env.get('MARATHON_APP_ID'),
            'api_url': "https://marathon.service.consul:8443/v2/apps{}"
        }

        self.cache_dir = '/tmp/'
        self.token_expiration = 600000
        self.age = 20
        self.audience = 'https://watts.data.kit.edu'
        self.tts = 'https://watts.data.kit.edu'
        self.iam_endpoint = 'https://iam-test.indigo-datacloud.eu/'
        self.token_endpoint = self.iam_endpoint + 'token'
        self.introspect_endpoint = self.iam_endpoint + 'introspect'
        self.credential_endpoint = 'https://watts.data.kit.edu/api/v2/iam/credential'
        self.tts_output_data = '{}/output.json'.format(self.cache_dir)
        self.lock_file = "{}/lock".format(self.cache_dir)
        self.user_cert = "{}/usercert.crt".format(self.cache_dir)
        self.user_key = "{}/userkey.key".format(self.cache_dir)
        self.user_passwd = "{}/userpasswd.txt".format(self.cache_dir)
        self.user_proxy = "{}/userproxy.pem".format(self.cache_dir)
        self.exchanged_token = ""

    def check_tts_data(self):
        """Checks and refresh tts data.

        Workflow:
            - Check cached TTS data
                - if exists and it's up to date -> ok
                - if it's not up to date -> refresh
                - else -> exchange token
        """
        logging.debug("Check tts output data: %s", self.tts_output_data)
        if os.path.exists(self.tts_output_data):
            ctime = os.stat(self.tts_output_data).st_ctime
            since = time.time() - ctime
            logging.debug("Check expiration time: %s > %s",
                          since, self.token_expiration)
            if since > self.token_expiration:
                logging.debug("Token about to expire. Get tts data...")
                tts_data = self.get_tts_data(True)
            else:
                logging.debug("Token OK.")
                return True
        else:
            logging.debug("Token not exist, get exchange token...")
            self.exchanged_token = self.get_exchange_token()
            if isinstance(self.exchanged_token, int):
                logging.error("Get exchange token error: %s",
                              self.exchanged_token)
                return False
            else:
                logging.debug("Token OK.")
                tts_data = self.get_tts_data(self.exchanged_token)

        return tts_data

    def get_certificate(self, url):
        """Retrieve the certificate.

        Returns:
            The given tts token

        Raises:
            - redirect errors
            - curl errors

        TO DO:
            - Manage controls (gestisci controlli)
        """
        bearer = 'Authorization: Bearer ' + \
            str(self.exchanged_token).split('\n', 1)[0]
        data = json.dumps({"service_id": "x509"})

        logging.debug("Create headers and buffers")
        headers = StringIO()
        buffers = StringIO()

        logging.debug("Prepare CURL")
        curl = pycurl.Curl()
        curl.setopt(pycurl.URL, url)
        curl.setopt(pycurl.HTTPHEADER, [
                    bearer, 'Content-Type: application/json'])
        curl.setopt(pycurl.POST, 1)
        curl.setopt(pycurl.POSTFIELDS, data)
        curl.setopt(curl.WRITEFUNCTION, buffers.write)
        curl.setopt(curl.HEADERFUNCTION, headers.write)
        curl.setopt(curl.VERBOSE, True)

        try:
            logging.debug("Perform CURL call")
            curl.perform()
            status = curl.getinfo(curl.RESPONSE_CODE)
            logging.debug("Result status: %s", status)
            logging.debug("Close CURL")
            curl.close()
            logging.debug("Get body content")
            body = buffers.getvalue()
            logging.debug("Body: %s", body)

            if str(status) != "303":
                logging.error(
                    "On 'get redirected with curl': http error: %s", str(status))
                return False
        except pycurl.error as error:
            errno, errstr = error
            logging.error('A pycurl error n. %s occurred: %s', errno, errstr)
            return False

        logging.debug("Manage redirect")
        redirect = self.tts
        for item in headers.getvalue().split("\n"):
            if "location" in item:
                logging.debug("Redirect location %s", item)
                redirect = redirect + item.strip().replace("location: ", "")

                headers = {'Authorization': 'Bearer ' +
                           self.exchanged_token.strip()}
                response = requests.get(redirect, headers=headers)

                try:
                    response.raise_for_status()
                except requests.exceptions.HTTPError as err:
                    # Whoops it wasn't a 200
                    logging.error(
                        "Error in get certificate redirect: %s", str(err))
                    return False

                with open('/tmp/output.json', 'w') as outf:
                    outf.write(response.content)
            else:
                logging.error("No location in redirect response")

        return True

    def get_exchange_token(self):
        """Retrieve the access token.

        Exchange the access token with the given client id and secret.
        The refresh token in cached and the exchange token is kept in memory.

        TO DO:
            - Add controls (aggiungi controlli)
        """

        logging.debug("Prepare header")

        data = HTTPHeaderDict()
        data.add('grant_type', 'urn:ietf:params:oauth:grant-type:token-exchange')
        data.add('audience', self.audience)
        data.add('subject_token', self.iam_token)
        data.add('scope', 'openid profile offline_access')

        logging.debug("Call get exchanged token with data: %s", data)

        response = requests.post(self.token_endpoint, data=data, auth=(
            self.client_id, self.client_secret), verify=True)
        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as err:
            # Whoops it wasn't a 200
            logging.error("Error in get exchange token: %s", err)
            return response.status_code

        result = json.loads(response.content)
        logging.debug("Result: %s", result)

        logging.debug("Override refresh token")
        with open('/tmp/refresh_token', 'w') as outf:
            outf.write(result["refresh_token"])

        return result["access_token"]

    def introspection(self, iam_client_id, iam_client_secret, exchanged_token):
        """Get info through introspection with the given client id, secret and token.

        TO DO:
            - Add controls (aggiungi controlli)
        """

        iam_client_id = self.client_id
        iam_client_secret = self.client_secret

        data = HTTPHeaderDict()
        data.add('token', exchanged_token)

        response = requests.post(self.introspect_endpoint, data=data, auth=(
            iam_client_id, iam_client_secret), verify=False)

        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as err:
            # Whoops it wasn't a 200
            logging.error("Error in introspection: %s", err)
            logging.error("HTTP error. Response status: %s",
                          response.status_code)
            return response.status_code

        with open('/tmp/introspection', 'w') as outf:
            outf.write(response.content)

    def refresh_token(self, refresh_token):
        """Request with refresh token.

        TO DO:
            - Manage result out of the function (gestisci result fuori dalla funzione)
        """
        data = HTTPHeaderDict()
        data.add('client_id', self.client_id)
        data.add('client_secret', self.client_secret)
        data.add('grant_type', 'refresh_token')
        data.add('refresh_token', refresh_token)

        logging.debug("Refresh token. data: %s", data)

        response = requests.post(self.token_endpoint, data=data, verify=True)

        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as err:
            # Whoops it wasn't a 200
            logging.error("Error in refresh_token: %s", err)
            logging.error("HTTP error. Response status: %s",
                          response.status_code)
            return response.status_code

        logging.debug("Response content: %s", response.content)
        result = json.loads(response.content)
        return result["access_token"]

    def get_tts_data(self, exchange=False):
        """Get TTS data using a lock procedure.

        Phases:
            - get lock
            - retrieve_tts_data
            - release lock

        Params:
            exchange (Bool): indicate if we have to do the exchange
        """
        logging.debug("Check lock file %s", self.lock_file)
        if os.path.exists(self.lock_file):
            ctime = os.stat(self.lock_file).st_ctime
            age = time.time() - ctime
            logging.debug("Check age of %s: %s < %s",
                          self.lock_file, age, self.age)
            if age < self.age:
                logging.debug("Update in progres. Go to sleep...")
                time.sleep(self.age - age)
            else:
                logging.debug("Stale lock file. Removing %s...",
                              self.lock_file)
                os.remove(self.lock_file)
        logging.debug("Update last use time of %s", self.lock_file)
        open(self.lock_file, 'w+').close()

        if exchange:
            logging.debug("Exchange /tmp/refresh_token")
            with file('/tmp/refresh_token') as refresh_t_file:
                refresh_token = refresh_t_file.read()
                logging.debug("Refresh token")
                self.exchanged_token = self.refresh_token(
                    refresh_token.strip())
                if isinstance(self.exchanged_token, int):
                    logging.error("Error in refresh_token")

        logging.debug("Refresh token")
        if self.get_certificate(self.credential_endpoint):

            logging.debug("Load json and prepare objects")
            with open('/tmp/output.json') as tts_data_file:
                tts_data = json.load(tts_data_file)

            with open(self.user_cert, 'w+') as cur_file:
                cur_file.write(
                    str(tts_data['credential']['entries'][0]['value']))

            with open(self.user_key, 'w+') as cur_file:
                cur_file.write(
                    str(tts_data['credential']['entries'][1]['value']))

            with open(self.user_passwd, 'w+') as cur_file:
                cur_file.write(
                    str(tts_data['credential']['entries'][2]['value']))

            try:
                logging.debug("Change user key mod")
                os.chmod(self.user_key, 0o600)
            except OSError as err:
                logging.error(
                    "Permission denied to chmod passwd file: %s", err)
                return False

            logging.debug("Remove lock")
            os.remove(self.lock_file)

            return True

        return False

    def generate_proxy(self):
        """Generates proxy with grid-proxy-init only if there are not errors."""

        if self.check_tts_data():
            logging.debug("Generating proxy for %s", self.exchanged_token)

            command = "grid-proxy-init -valid 160:00 -key {} -cert {} -out {} -pwstdin ".format(
                self.user_key, self.user_cert, self.user_proxy
            )
            with open(self.user_passwd) as my_stdin:
                my_passwd = my_stdin.read()
            proxy_init = subprocess.Popen(
                command,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                shell=True
            )

            logging.debug("Execute proxy")
            proxy_out, proxy_err = proxy_init.communicate(input=my_passwd)

            logging.debug("Proxy result: %s", proxy_init.returncode)
            if proxy_init.returncode > 0:
                logging.error("grid-proxy-init failed for token %s",
                              self.exchanged_token)
                logging.error("grid-proxy-init failed stdout %s", proxy_out)
                logging.error("grid-proxy-init failed stderr %s", proxy_err)
            else:
                return self.user_proxy
        else:
            logging.error("Error occured in check_tts_data!")


if __name__ == '__main__':

    logging.basicConfig(filename='/var/log/ttscache/certcache.log',
                        format='[%(filename)s@%(lineno)d][%(asctime)s](%(levelname)s)->(%(message)s)', level=logging.DEBUG)

    logging.info("CALLING GET PROXY")

    # imports tokens, id and secret
    ENV = {
        'IAM_TOKEN': os.environ.get("IAM_TOKEN", None),
        'REFRESH_TOKEN': os.environ.get("IAM_REFRESH_TOKEN", None),
        'CLIENT_ID': os.environ.get("IAM_CLIENT_ID", None),
        'CLIENT_SECRET': os.environ.get("IAM_CLIENT_SECRET", None),
        'MARATHON_USER': os.environ.get("MARATHON_USER", None),
        'MARATHON_PASSWD': os.environ.get("MARATHON_PASSWD", None),
        'ZOOKEEPER_HOST_LIST': os.environ.get("ZOOKEEPER_HOST_LIST", None),
    }

    logging.info("IAM_TOKEN = %s", ENV.get('IAM_TOKEN'))
    logging.info("IAM_REFRESH_TOKEN = %s", ENV.get('REFRESH_TOKEN'))
    logging.info("IAM_CLIENT_= %s", ENV.get('CLIENT_ID'))
    logging.info("IAM_CLIENT_SECRET = %s", ENV.get('CLIENT_SECRET'))
    logging.info("MARATHON_USER = %s", ENV.get('MARATHON_USER'))
    logging.info("MARATHON_PASSWD = %s", ENV.get('MARATHON_PASSWD'))
    logging.info("ZOOKEEPER_HOST_LIST = %s", ENV.get('ZOOKEEPER_HOST_LIST'))

    PROXY_MANAGER = ProxyManager(ENV)

    print("Content-type: application/octet-stream\n\n")
    print("Content-Disposition: attachment; filename=.pem")
    print()
    PROXY_FILE = PROXY_MANAGER.generate_proxy()

    if PROXY_FILE is not None:
        with open(PROXY_FILE, 'rb') as proxy_file:
            print(proxy_file.read())
    else:
        logging.error("Cannot find Proxy file: '%s'", PROXY_FILE)
        print("Content-type: text/html")
        print()
        print("<p>grid-proxy-info failed</p>")
    sys.exit()
